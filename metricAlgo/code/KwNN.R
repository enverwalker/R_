## Евклидово расстояние
euclideanDistance <- function(u, v)# u-первая координата, v-вторая(параметры фунцкии расстояния) 
{
  sqrt(sum((u - v)^2)) # корень от(суммы(sum) квадратов разностей координат двух точек)
}

# присваиваем цвета: каждому классу-соответствующий
colors <- c("setosa" = "red", "versicolor" = "green3", "virginica" = "blue")

# инициализация выборки ирисов
iris30 = iris[sample(c(1:150), replace=FALSE), 3:5] #3 колонка - длина лепестка, 4 - ширина лепестка, 5 - класс ириса

# отрисовка выборки ирисов
plot(iris30[, 1:2], pch = 21, bg = colors[iris30$Species], col = colors[iris30$Species]) #1 колонка - длина, 2 - ширина лепестка
xl <- iris30[, 1:3] #1 колонка - длина, 2 - ширина лепестка, 3 - класс ириса


## Сортируем объекты согласно расстояния до объекта z()
sortObjectsByDist <- function(xl, z, metricFunction = euclideanDistance) #параметры функции сортировки: ирис, точка, функция расстояния
{
  # определяем размерность выборки xl, [1]-строки, [2]-столбцы
  l <- dim(xl)[1] # количество строк, они равны числу ирисов
  n <- dim(xl)[2] - 1 # количество столбцов(здесь размеры лепестков ирисов), -1, так как последний столбец - это класс
  
  ## Создаём матрицу расстояний
  distances <- matrix(NA, l, 2) # l - это кол-во строк, 2 - это кол-во стобцов; NA значит, что матрица создаётся сначала пустой
  
  for (i in 1:l) #i варьируется от 1 до l, а l у нас 150, как ирисов
  {
    # в i-ою строку distances, во все столбцы(можно было написать 1:2) инициализируется:
    distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z)) # расстояние от ириса i до точки z
    # в первом столбце i - номер ириса, во втором - metricFunction(расстояние до него от точки z)
  }
  ## Сортируем
  orderedXl <- xl[order(distances[, 2]), ] # отсортированная выборка по расстояниям
  # order сортирует выборку, используя все строки и второй столбец ditances,
  # в котором хранятся расстояния от ирисов, до каждой точки z.!После запятой все столбцы(они же параметры ирисов)
  return (orderedXl);
}



## Применяем метод kNN
kNN <- function(xl, z, k, q)
{
  ## Сортируем выборку согласно классифицируемого объекта
  orderedXl <- sortObjectsByDist(xl, z)
  #3 столбец orderedXl содержит класс
  v1 <- c('setosa', 'versicolor', 'virginica') #создаём вектор с именами классов
  v2 <- c(0,0,0) #создаём пустой вектор
  
  for(i in 1:k){ 
    orderedXl[i, 4] = q^i #для первых k соседей каждой точки присваивается вес(в 4 столбец)(каждому соседу)
  }
  #4 столбец orderedXl содержит вес
  
  classes <- orderedXl[1:k, 3:4]
  #classes содержит класс и вес первых k соседей каждой точки

  
  v2[1]=sum(classes[classes$Species=='setosa', 2])
  #суммируем величины 2го столбца, где вес для сетосы, аналогично другие
  v2[2]=sum(classes[classes$Species=='versicolor', 2])
  v2[3]=sum(classes[classes$Species=='virginica', 2])
  
  gen <- cbind(v1,v2) #объединим векторы v1 и v2
  class <- v1[which.max(v2)]
  #which.max возвращает порядковый номер элемента объекта с максимальным значением
  #таким образом в class через индекс попадает имя класса(где вес максимален)
  return (class) 
  
}


## Рисуем выборку
colors <- c("setosa" = "red", "versicolor" = "green3", "virginica" = "blue")
plot(iris[, 3:4], pch = 21, bg = colors[iris$Species], col = colors[iris$Species])


## Классификация одного заданного объекта
for (ytmp in seq(0, 3, by=0.1)){
  for (xtmp in seq(0, 7, by=0.1)){
    
    z <- c(xtmp, ytmp)
    xl <- iris[, 3:5]
    class <- kNN(xl, z, k=6, q=0.8)
    points(z[1], z[2], pch = 1, col = colors[class]) #красит точку в цвет опред. класса
  }
}
